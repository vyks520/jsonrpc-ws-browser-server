function e(e,r,t,n){return new(t||(t=Promise))((function(s,o){function i(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var r;e.done?s(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(i,a)}l((n=n.apply(e,r||[])).next())}))}function r(e){return new Promise((r=>{setTimeout(r,e)}))}function t(e,r){if(i("object"==typeof e,"not an object or array"),Array.isArray(e))return e;{const t=r.map((()=>{}));for(const n of Object.keys(e)){const s=r.indexOf(n);i(-1!==s,`unknown param: ${n}`),t[s]=e[n]}return t}}"function"==typeof SuppressedError&&SuppressedError;const n=/(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/gm,s=/([^\s,]+)/g;function o(e){const r=e.toString().replace(n,"");return r.slice(r.indexOf("(")+1,r.indexOf(")")).match(s)||[]}function i(e,r){if(!e)throw r}var a,l=Object.freeze({__proto__:null,assert:i,getParamNames:o,resolveParams:t,sleep:r});function c(e){return null!==e.id&&void 0!==e.id||void 0!==e.error}!function(e){e[e.ParseError=-32700]="ParseError",e[e.InvalidRequest=-32600]="InvalidRequest",e[e.MethodNotFound=-32601]="MethodNotFound",e[e.InvalidParams=-32602]="InvalidParams",e[e.InternalError=-32603]="InternalError"}(a||(a={}));class u{constructor(e,r){this.name="JSONRPCError",this.code=e,this.message=r||e}info(){return`${this.name}: ${this.message}`}}class d{constructor({error:e,request:r,result:t}){this.jsonrpc="2.0",t&&e||(this.error=new u(a.InvalidRequest,"must specify either result or error")),t&&e||(this.error=new u(a.InvalidRequest,"result and error are mutually exclusive")),this.id=r?r.id:null,this.error=e,this.request=r,this.result=void 0===t?null:t}toJSON(){const{jsonrpc:e,id:r,error:t,result:n}=this;return t?{jsonrpc:e,id:r,error:t}:{jsonrpc:e,id:r,result:n}}stringify(){return JSON.stringify(this.toJSON())}}class h{static from(e){const{jsonrpc:r,method:t,params:n,id:s}=e;return new h(r,s,t,n)}constructor(e,r,t,n){this.jsonrpc=e,this.id=r,this.method=t,this.params=n,i("2.0"===e,"invalid rpc version"),i(function(e){return null==e||"string"==typeof e||"number"==typeof e&&Number.isSafeInteger(e)}(r),"invalid id"),i("string"==typeof t,"invalid method")}}function f(e,r){if(!e)throw new u(400,r||"Assertion failed")}function v(e,r,t){if(e!=r)throw new u(400,`${t||"Assertion failed"}`)}class m{constructor(r,n){this.url=r,this.namespace=n,this.methods={},this.ws=null,this.closed=!1,this.onopen=null,this.onerror=null,this.handleWsMessage=r=>e(this,void 0,void 0,(function*(){let e;try{e=JSON.parse(r)}catch(e){const r=new u(a.ParseError,"Parse error, request data parsing failed"),t=new d({error:r});return this.send(t.stringify()),void console.error(r.info())}if(Array.isArray(e)&&0===e.length){const e=new u(a.InvalidRequest,"Invalid Request"),r=new d({error:e});return this.send(r),void console.error(e.info())}if(Array.isArray(e)){const r=e.map((e=>this.handleRequest(e))),t=(yield Promise.all(r)).filter(c);this.send(t)}else{const r=yield this.handleRequest(e);this.send(c(r)?r:"")}})),this.handleRequest=r=>e(this,void 0,void 0,(function*(){let e;try{e=h.from(r)}catch(e){const t=new u(a.InvalidRequest,`${e}, Invalid Request`);return new d({request:{id:(null==r?void 0:r.id)||null},error:t})}const n=this.methods[e.method];if(!n){const r=new u(a.MethodNotFound,"Method not found");return new d({request:e,error:r})}let s,o;try{s=void 0!==e.params?t(e.params,n.params):[]}catch(r){const t=new u(a.InvalidParams,`${r}, Invalid params`);return new d({request:e,error:t})}try{const r={assert:f,assertEqual:v,request:e};o=yield n.method.apply(r,s)}catch(r){return r instanceof u||(r=new u(a.InternalError,`${r}, Internal error`)),new d({request:e,error:r})}return new d({request:e,result:o})}))}register(e,r){const t=this.namespace?`${this.namespace}.${e}`:e;if(this.methods[t])return"json rpc server method already exists";const n=o(r);return this.methods[t]={method:r,params:n},null}close(){this.closed=!0,this.ws&&this.ws.close()}open(){const t=()=>new Promise(((r,t)=>{this.closed=!1;try{const n=new WebSocket(this.url);this.ws=n,n.onopen=()=>{var e;null===(e=this.onopen)||void 0===e||e.call(this),r()},n.onerror=()=>{var e;const r=new u(a.InternalError,`connection to '${this.url}' failed`).info();null===(e=this.onerror)||void 0===e||e.call(this,r),t(r)},n.onclose=function(e){},n.onmessage=r=>e(this,void 0,void 0,(function*(){yield this.handleWsMessage(r.data)}))}catch(e){t(new u(a.InternalError,e))}})),n=t=>e(this,void 0,void 0,(function*(){var e;let n=10;for(let s=0;;){if(n=s<=10?5e3:6e4,yield r(n),this.closed)return;this.ws&&3!==this.ws.readyState||(3===(null===(e=null==this?void 0:this.ws)||void 0===e?void 0:e.readyState)&&this.ws.close(),console.warn("jsonRpcServer: WebSocket reconnect"),yield t().then((()=>{s=0,n=5e3})).catch((e=>{console.error(e)})),s<=10&&s++)}}));return new Promise(((r,s)=>e(this,void 0,void 0,(function*(){yield t().then((()=>{r(null)})).catch((e=>{s(e)})),n(t).then()}))))}send(e){if(!this.ws)return new u(a.InternalError,"service is not open").info();let r;r=e&&"object"==typeof e?e.stringify?e.stringify():JSON.stringify(e):e;try{this.ws.send(r)}catch(e){console.error(new u(a.InternalError,e).info())}}}export{u as JsonRpcError,a as JsonRpcErrorCode,h as JsonRpcRequest,d as JsonRpcResponse,m as JsonRpcServer,f as rpcAssert,v as rpcAssertEqual,l as utils};
